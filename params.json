{"tagline":"Convert your model instances and querysets into dicts and list with style.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration.","body":"# django-preserialize\r\n\r\ndjango-preserialize is a one-stop shop for ensuring an object is free of\r\n`Model` and `QuerySet` instances. By default, all non-relational fields\r\nwill be included as well as the primary keys of local related fields.\r\nThe resulting containers will simply be `dict`s and `list`s.\r\n\r\n_BTW, have a better name? Give me a suggestion!_\r\n\r\n## Install\r\n\r\n```bash\r\npip install django-preserialize\r\n```\r\n\r\n## Docs\r\n\r\nA serialized user object might look like this:\r\n\r\n```python\r\n>>> from preserialize.serialize import serialize\r\n>>> serialize(user)\r\n{\r\n    'date_joined': datetime.datetime(2009, 5, 16, 15, 52, 40),\r\n    'email': u'jon@doe.com',\r\n    'first_name': u'Jon',\r\n    'groups': [5],\r\n    'id': 1,\r\n    'is_active': True,\r\n    'is_staff': True,\r\n    'is_superuser': True,\r\n    'last_login': datetime.datetime(2012, 3, 3, 17, 40, 41, 927637),\r\n    'last_name': u'Doe',\r\n    'password': u'!',\r\n    'user_permissions': [1, 2, 3],\r\n    'username': u'jdoe'\r\n}\r\n```\r\n\r\nThis can then be passed off to a serializer/encoder, e.g. JSON, to turn\r\nit into a string for the response body (or whatever else you want to do).\r\n\r\n## Serialize Options\r\n\r\nSome fields may not be appropriate or relevent to include as output.\r\nTo customize which fields get included or excluded, the\r\nfollowing arguments can be passed to ``serialize``:\r\n\r\n* `fields` - A list of fields names to include. Method names can also be\r\nspecified that will be called when being serialized. Default is all local \r\nfields and local related fields. See also: `exclude`, `key_map`\r\n* `exclude` - A list of fields names to exclude (this takes precedence\r\nover fields). Default is `None`. See also: `fields`, `key_map`\r\n* `related` - A dict of related object accessor and configs (see below) for\r\nhandling related object.\r\n* `values_list` - This option only applies to `QuerySet`s. Returns a list of\r\nlists with the field values (like Django's `ValuesListQuerySet`). Default \r\nis `False`.\r\n* `flatten` - Applies only if `values_list` is `True` and one field is \r\nspecified. If `True`, flattens out the list of lists into a single list of \r\nvalues. Default is `True`.\r\n* `key_prefix` - A string to be use to prefix the dict keys. To enable \r\ndynamic prefixes, the prefix may contain `'%(accessor)s' which will be the \r\nclass name for top-level objects or the accessor name for related objects. \r\nDefault is `None`.\r\n* `key_map` - A dictionary that maps the keys of the output dictionary to \r\nthe actual field/method names referencing the data. Default is `None`.  See \r\nalso: `fields`\r\n* `camelcase` - Converts all keys to a camel-case equivalent. This is \r\nmerely a convenience for conforming to language convention for consumers of \r\nthis content, namely JavaScript. Default is `False`.\r\n\r\n### Examples\r\n\r\n```python\r\n>>> serialize(user, fields=['username', 'full_name'], key_map={'full_name': 'get_full_name'}, camelcase=True)\r\n{\r\n    'fullName': u'Jon Doe',\r\n    'username': u'jdoe'\r\n}\r\n\r\n>>> serialize(user, exclude=['password', 'groups', 'permissions'])\r\n{\r\n    'date_joined': datetime.datetime(2009, 5, 16, 15, 52, 40),\r\n    'email': u'jon@doe.com',\r\n    'first_name': u'Jon',\r\n    'id': 1,\r\n    'is_active': True,\r\n    'is_staff': True,\r\n    'is_superuser': True,\r\n    'last_login': datetime.datetime(2012, 3, 3, 17, 40, 41, 927637),\r\n    'last_name': u'Doe',\r\n    'username': u'jdoe'\r\n}\r\n```\r\n\r\n## Related Objects\r\n\r\nComposite resources are common when dealing with data that have _tight_\r\nrelationships. A user and their user profile is an example of this. It is \r\ninefficient for a client to have to make two separate requests for data \r\nthat is typically always consumed together.\r\n\r\n`serialize` supports the `related` keyword argument for defining options for\r\nrelational fields. The following additional attributes (to the above) may be\r\ndefined:\r\n\r\n* `merge` - This option only applies to local `ForeignKey` or \r\n`OneToOneField`. This allows for merging this object's fields into the \r\nparent object.\r\n\r\n```python\r\n>>> serialize(user, related={'groups': {'fields': ['name']}, 'profile': {'merge': True}})\r\n{\r\n    'username': u'jdoe',\r\n    'groups': [{\r\n        'name': u'Managers'\r\n    }]\r\n    # profile attributes merged into the user\r\n    'twitter': '@jdoe',\r\n    'mobile': '123-456-7890',\r\n    ...\r\n}\r\n```\r\n\r\n## Conventions\r\n\r\n**Define a `data_template` dict for each model that will be serialized.**\r\n\r\nDefining a `data_template` enables reuse across different serialized\r\nobjects. Deconstructing the above example, we have:\r\n\r\n```python\r\n# Render a list of group names.. note that 'values_list'\r\n# options is implied here since there is only one field\r\n# specified. It is here to be explicit.\r\ngroup_template = {\r\n    'fields': ['name'],\r\n    'values_list': True,\r\n}\r\n\r\n# User profiles are typically only wanted to be merge into\r\n# User, so we can add the 'merge' option. Remember this simply\r\n# gets ignored if 'UserProfile' is the top-level object being\r\n# serialized.\r\nprofile_template = {\r\n    'merge': True\r\n}\r\n\r\n# Users typically always include some related data (groups and their\r\n# profile), so we can reference the above templates in this one.\r\nuser_template = {\r\n    'exclude': ['password', 'user_permissions'],\r\n    'related': {\r\n        'groups': group_template,\r\n        'profile': profile_template,\r\n    }\r\n}\r\n\r\n# Everyone is the pool!\r\nusers = User.objects.all()\r\n# Now we can use Python's wonderful argument _unpacking_ syntax. Clean.\r\nserialize(users, **user_template)\r\n```\r\n\r\n## Niceties\r\n\r\n### Mixed Types\r\n\r\nIt is not always the case that a single model instance or queryset is the\r\nsource of data for a resource. `serialize` also understands `dict`s and any\r\niterable of `dict`s. They will be treated similarly to the model instances.\r\n\r\n### Pseudo-selectors\r\n\r\nThe `fields` and `exclude` options understands four _pseudo-selectors_ which\r\ncan be used in place of typing out all of a model's field names (although\r\nbeing explicit is always better).\r\n\r\n- `:pk` - the primary key field of the model\r\n- `:local` - all local fields on a model (including local foreign keys and\r\nmany-to-many fields)\r\n- `:related` - all related fields (reverse foreign key and many-to-many)\r\n- `:all` - a composite of all selectors above and thus any an all fields\r\non or related to a model\r\n\r\nYou can use them like this:\r\n\r\n```python\r\n# The two selectors here are actually the default, but defined\r\n# for the example.\r\nserialize(user, fields=[':pk', ':local'], exclude=['password'])\r\n```\r\n\r\nFor those curious, try this:\r\n\r\n```python\r\n>>> from pprint import pprint\r\n>>> from preserialize.utils import resolver\r\n>>> pprint(resolver._get_fields(User))\r\n{':all': {'date_joined': <django.db.models.fields.DateTimeField: date_joined>,\r\n          'email': <django.db.models.fields.EmailField: email>,\r\n          'first_name': <django.db.models.fields.CharField: first_name>,\r\n          'groups': <django.db.models.fields.related.ManyToManyField: groups>,\r\n          'id': <django.db.models.fields.AutoField: id>,\r\n          'is_active': <django.db.models.fields.BooleanField: is_active>,\r\n          'is_staff': <django.db.models.fields.BooleanField: is_staff>,\r\n          'is_superuser': <django.db.models.fields.BooleanField: is_superuser>,\r\n          'last_login': <django.db.models.fields.DateTimeField: last_login>,\r\n          'last_name': <django.db.models.fields.CharField: last_name>,\r\n          'logentry_set': <RelatedObject: admin:logentry related to user>,\r\n          'password': <django.db.models.fields.CharField: password>,\r\n          'user_permissions': <django.db.models.fields.related.ManyToManyField: user_permissions>,\r\n          'username': <django.db.models.fields.CharField: username>},\r\n ':local': {'date_joined': <django.db.models.fields.DateTimeField: date_joined>,\r\n            'email': <django.db.models.fields.EmailField: email>,\r\n            'first_name': <django.db.models.fields.CharField: first_name>,\r\n            'groups': <django.db.models.fields.related.ManyToManyField: groups>,\r\n            'id': <django.db.models.fields.AutoField: id>,\r\n            'is_active': <django.db.models.fields.BooleanField: is_active>,\r\n            'is_staff': <django.db.models.fields.BooleanField: is_staff>,\r\n            'is_superuser': <django.db.models.fields.BooleanField: is_superuser>,\r\n            'last_login': <django.db.models.fields.DateTimeField: last_login>,\r\n            'last_name': <django.db.models.fields.CharField: last_name>,\r\n            'password': <django.db.models.fields.CharField: password>,\r\n            'user_permissions': <django.db.models.fields.related.ManyToManyField: user_permissions>,\r\n            'username': <django.db.models.fields.CharField: username>},\r\n ':pk': {'id': <django.db.models.fields.AutoField: id>},\r\n ':related': {'logentry_set': <RelatedObject: admin:logentry related to user>}\r\n```\r\n\r\nNote, in practice these selectors are not generally used.","name":"Django Preserialize"}