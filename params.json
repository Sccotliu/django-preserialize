{"name":"Django Preserialize","tagline":"Convert your model instances and querysets into dicts and list with style.","body":"# django-preserialize\r\n\r\n[![Build Status](https://travis-ci.org/bruth/django-preserialize.png)](https://travis-ci.org/bruth/django-preserialize) [![Coverage Status](https://coveralls.io/repos/bruth/django-preserialize/badge.png?branch=master)](https://coveralls.io/r/bruth/django-preserialize?branch=master)\r\n\r\ndjango-preserialize is a one-stop shop for ensuring an object is free of `Model` and `QuerySet` instances. By default, all non-relational fields will be included as well as the primary keys of local related fields. The resulting containers will simply be `dict`s and `list`s.\r\n\r\n## Install\r\n\r\n```bash\r\npip install django-preserialize\r\n```\r\n\r\n## Docs\r\n\r\nA serialized user object might look like this:\r\n\r\n```python\r\n>>> from preserialize.serialize import serialize\r\n>>> serialize(user)\r\n{\r\n    'date_joined': datetime.datetime(2009, 5, 16, 15, 52, 40),\r\n    'email': u'jon@doe.com',\r\n    'first_name': u'Jon',\r\n    'groups': [5],\r\n    'id': 1,\r\n    'is_active': True,\r\n    'is_staff': True,\r\n    'is_superuser': True,\r\n    'last_login': datetime.datetime(2012, 3, 3, 17, 40, 41, 927637),\r\n    'last_name': u'Doe',\r\n    'password': u'!',\r\n    'user_permissions': [1, 2, 3],\r\n    'username': u'jdoe'\r\n}\r\n```\r\n\r\nThis can then be passed off to a serializer/encoder, e.g. JSON, to turn\r\nit into a string for the response body (or whatever else you want to do).\r\n\r\n## Serialize Options\r\n\r\nSome fields may not be appropriate or relevent to include as output.\r\nTo customize which fields get included or excluded, the\r\nfollowing arguments can be passed to ``serialize``:\r\n\r\n**`fields`**\r\n\r\nA list of fields names to include. Method names can also be specified that will be called when being serialized. Default is all local fields and local related fields. See also: `exclude`, `aliases`\r\n\r\n**`exclude`**\r\n\r\nA list of fields names to exclude (this takes precedence over fields). Default is `None`. See also: `fields`, `aliases`\r\n\r\n**`related`**\r\n\r\nA dict of related object accessors and configs (see below) for handling related objects.\r\n\r\n**`values_list`**\r\n\r\nThis option only applies to `QuerySet`s. Returns a list of lists with the field values (like Django's `ValuesListQuerySet`). Default is `False`.\r\n\r\n**`flat`**\r\n\r\nApplies only if one field is specified in `fields`. If applied to a `QuerySet` and if `values_list` is `True` the values will be flattened out. If applied to a model instance, the single field value will used (in place of the dict). Note, if `merge` is true, this option has not effect. Default is `True`.\r\n\r\n**`prefix`**\r\n\r\nA string to be use to prefix the dict keys. To enable dynamic prefixes, the prefix may contain `'%(accessor)s'` which will be the class name for top-level objects or the accessor name for related objects. Default is `None`.\r\n\r\n**`aliases`**\r\n\r\nA dictionary that maps the keys of the output dictionary to the actual field/method names referencing the data. Default is `None`. See also: `fields`\r\n\r\n**`camelcase`**\r\n\r\nConverts all keys to a camel-case equivalent. This is merely a convenience for conforming to language convention for consumers of this content, namely JavaScript. Default is `False`.\r\n\r\n**`allow_missing`**\r\n\r\nAllow for missing fields (rather than throwing an error) and fill in the value with `None`.\r\n\r\n### Hooks\r\n\r\nHooks enable altering the objects that are serialized at each level.\r\n\r\n**`prehook`**\r\n\r\n\r\n\r\nA function that takes and returns an object. For `QuerySet`s it can be used for filtering or annotating additional data to each model instance. For `Model` instances it can be prefetching additional data, swapping out an instance or whatever is necessary prior to serialization.\r\n\r\nSince filtering `QuerySet`s is a common use case, a simple dict can be supplied instead of a function that will be passed to the `filter` method.\r\n\r\nHere are two examples for filtering `posts` by the requesting user.\r\n\r\nThe shorthand method of using a `dict`:\r\n\r\n```python\r\ndef view(request):\r\n    template = {\r\n        'related': {\r\n            'posts': {\r\n                'prehook': {'user': request.user},\r\n            }\r\n        }\r\n    }\r\n    ...\r\n```\r\n\r\nFor applying conditional logic, a function can be used:\r\n\r\n```python\r\nfrom functools import partial\r\n\r\ndef filter_by_user(queryset, user):\r\n    if not user.is_superuser:\r\n        queryset = queryset.filter(user=user)\r\n    return queryset\r\n\r\ndef view(request):\r\n    template = {\r\n        'related': {\r\n            'posts': {\r\n                'prehook': partial(filter_by_user, request=request)\r\n            }\r\n        }\r\n    }\r\n    ...\r\n```\r\n\r\n**`posthook`**\r\n\r\nA function that takes the original model instance and the serialized attrs for post-processing. This is specifically useful for augmenting or modifying the data prior to being added to the large serialized data structure.\r\n\r\nEven if the related object (like `posts` above) is a `QuerySet`, this hook is applied per object in the `QuerySet`. This is because it would rarely ever be necessary to process a list of objects as a whole since filtering can already be performed above (using the `prehook`) prior to serialization.\r\n\r\nHere is an example of adding resource links to the output data based on the serialized attributes:\r\n\r\n```python\r\nfrom functools import partial\r\nfrom django.core.urlresolvers import reverse\r\n\r\ndef add_resource_links(instance, attrs, request):\r\n    uri = request.build_absolute_uri\r\n    attrs['_links'] = {\r\n        'self': {\r\n            'href': uri(reverse('api:foo:bar', kwargs={'pk': attrs.id})),\r\n        },\r\n        ...\r\n    }\r\n    return attrs\r\n\r\ntemplate = {\r\n    'posthook': partial(add_resource_links, request=request),\r\n    ...\r\n}\r\n```\r\n\r\n### Examples\r\n\r\n```python\r\n# The field names listed are after the mapping occurs\r\n>>> serialize(user, fields=['username', 'full_name'], aliases={'full_name': 'get_full_name'}, camelcase=True)\r\n{\r\n    'fullName': u'Jon Doe',\r\n    'username': u'jdoe'\r\n}\r\n\r\n>>> serialize(user, exclude=['password', 'groups', 'permissions'])\r\n{\r\n    'date_joined': datetime.datetime(2009, 5, 16, 15, 52, 40),\r\n    'email': u'jon@doe.com',\r\n    'first_name': u'Jon',\r\n    'id': 1,\r\n    'is_active': True,\r\n    'is_staff': True,\r\n    'is_superuser': True,\r\n    'last_login': datetime.datetime(2012, 3, 3, 17, 40, 41, 927637),\r\n    'last_name': u'Doe',\r\n    'username': u'jdoe'\r\n}\r\n\r\n>>> serialize(user, fields=['foo', 'bar', 'baz'], allow_missing=True)\r\n{\r\n    'foo': None,\r\n    'bar': None,\r\n    'baz': None,\r\n}\r\n```\r\n\r\n## Related Objects\r\n\r\nComposite resources are common when dealing with data that have _tight_ relationships. A user and their user profile is an example of this. It is inefficient for a client to have to make two separate requests for data that is typically always consumed together.\r\n\r\n`serialize` supports the `related` keyword argument for defining options for relational fields. The following additional argument (to the above) may be defined:\r\n\r\n**`merge`**\r\n\r\nThis option only applies to local `ForeignKey` or `OneToOneField`. This allows for merging the related object's fields into the parent object.\r\n\r\n```python\r\n>>> serialize(user, related={'groups': {'fields': ['name']}, 'profile': {'merge': True}})\r\n{\r\n    'username': u'jdoe',\r\n    'groups': [{\r\n        'name': u'Managers'\r\n    }]\r\n    # profile attributes merged into the user\r\n    'twitter': '@jdoe',\r\n    'mobile': '123-456-7890',\r\n    ...\r\n}\r\n```\r\n\r\n## Conventions\r\n\r\n**Define a template dict for each model that will be serialized.**\r\n\r\nDefining a _template_ enables reuse across different serialized objects as well as increases readability and maintainability. Deconstructing the above example, we have:\r\n\r\n```python\r\n# Render a list of group names.. note that 'values_list'\r\n# options is implied here since there is only one field\r\n# specified. It is here to be explicit.\r\ngroup_template = {\r\n    'fields': ['name'],\r\n    'values_list': True,\r\n}\r\n\r\n# User profiles are typically always wanted to be merged into\r\n# User, so we can add the 'merge' option. Remember this simply\r\n# gets ignored if 'UserProfile' is the top-level object being\r\n# serialized.\r\nprofile_template = {\r\n    `exclude`: ['user'],\r\n    'merge': True,\r\n}\r\n\r\n# Users typically always include some related data (groups and their\r\n# profile), so we can reference the above templates in this one.\r\nuser_template = {\r\n    'exclude': ['password', 'user_permissions'],\r\n    'related': {\r\n        'groups': group_template,\r\n        'profile': profile_template,\r\n    }\r\n}\r\n\r\n# Everyone is the pool!\r\nusers = User.objects.all()\r\n# Now we can use Python's wonderful argument _unpacking_ syntax.\r\n# Clean.\r\nserialize(users, **user_template)\r\n```\r\n\r\n## FAQ\r\n\r\n### Does the serializer only understand model fields?\r\n\r\nNo. In fact it is smart about accessing the _field_. The following steps are taken when attempting to get the value:\r\n\r\n1. Use `hasattr` to check if an attribute/property is present\r\n2. If the object support `__getitem__`, check if the key is present\r\n\r\nAssuming one of those two methods succeed, it will check if the value is callable and will call it (useful for methods). If the value is a `RelatedManager`, it will resolve the `QuerySet` and recursive downstream.\r\n\r\n### Does the serializer only support model instances?\r\n\r\nNo. It is not always the case that a single model instance or queryset is the source of data for a resource. `serialize` also understands `dict`s and any iterable of `dict`s. They will be treated similarly to the model instances.\r\n\r\n### My model has a ton of fields and I don't want to type them all out. What do I do?\r\n\r\nThe `fields` and `exclude` options understands four _pseudo-selectors_ which can be used in place of typing out all of a model's field names (although being explicit is typically better).\r\n\r\n**`:pk`**\r\n\r\nThe primary key field of the model\r\n\r\n**`:local`**\r\n\r\nAll local fields on a model (including local foreign keys and\r\nmany-to-many fields)\r\n\r\n**`:related`**\r\n\r\nAll related fields (reverse foreign key and many-to-many)\r\n\r\n**`:all`**\r\n\r\nA composite of all selectors above and thus any an all fields on or related to a model\r\n\r\nYou can use them like this:\r\n\r\n```python\r\n# The two selectors here are actually the default, but defined\r\n# for the example.\r\nserialize(user, fields=[':pk', ':local', 'foo'], exclude=['password'])\r\n```\r\n\r\n## CHANGELOG\r\n\r\n2013-05-01\r\n\r\n- Update `posthook` to take the original instance as the first argument and the serialized data as the second argument\r\n- Ensure the passed object is returned from `serialize` even if it does not qualify to be processed\r\n\r\n2013-04-29\r\n\r\n- Fix bug where the `flat` option was not respecting `merge`\r\n    - If `merge` is set, it takes precedence over flat\r\n\r\n2013-04-28\r\n\r\n- Add `prehook` and `posthook` options\r\n- Add support for `flat` option for model instances with a single field\r\n- Rename `key_map` to `aliases` for clarity\r\n- Rename `key_prefix` to `prefix`\r\n    - It is implied the prefix applies to the keys since this a serialization\r\n    utility\r\n- Internal clean up\r\n- Correct documentation regarding the `flat` option\r\n    - It was incorrectly named `flatten`\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}